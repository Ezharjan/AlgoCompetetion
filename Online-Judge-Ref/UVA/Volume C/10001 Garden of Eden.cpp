/* 13572331	10001	Garden of Eden	Accepted	C++	0.248	2014-05-01 07:05:10 */
#include<cstdio>
#include<string.h>
using namespace std;
int state, n;
char S[100];
char currentState[100];
char preState[100];

bool check(int state, int L, int M, int R){
	char LL, MM, RR;
	LL = '0' + state / 4;
	MM = '0' + (state % 4) / 2;
	RR = '0' + state % 2;
	bool ok = true;
	ok &= preState[L] == LL || preState[L] == '\0';
	ok &= preState[M] == MM || preState[M] == '\0';
	ok &= preState[R] == RR || preState[R] == '\0';
	return ok;
}

void fill(int state, int L, int M, int R){
	preState[R] = '0' + state % 2;
	preState[L] = '0' + state / 4;
	preState[M] = '0' + (state % 4) / 2;
}

bool DFS(int curPtr){
	if (curPtr == n)
		return true;
	for (int i = 0; i < 8; i++){
		if (currentState[curPtr] == S[i]){
			bool L, R, M;
			int left = curPtr - 1, right = curPtr + 1;
			if (left < 0)	left = n - 1;
			if (right >= n)	right = 0;

			L = M = R = false;
			if (!check(i, left, curPtr, right))	continue;
			if (preState[left] == '\0')	L = true;
			if (preState[curPtr] == '\0')	M = true;
			if (preState[right] == '\0') R = true;
			fill(i, left, curPtr, right);
			if (DFS(curPtr + 1))
				return true;
			if (L)	preState[left] = '\0';
			if (M)	preState[curPtr] = '\0';
			if (R)	preState[right] = '\0';
		}
	}
	return false;
}

int main(){
	while (scanf("%d%d%s", &state, &n, currentState) == 3){
		memset(preState, '\0', sizeof(preState));
		for (int i = 7, j = state;; i--, j >>= 1){
			if (j % 2 == 1)
				S[i] = '1';
			else
				S[i] = '0';
			if (i == 0)
				break;
		}
		if (DFS(0))
			puts("REACHABLE");
		else
			puts("GARDEN OF EDEN");
	}
	return 0;
}
/*


Garden of Eden
Cellular automata are mathematical idealizations of physical systems in which both space and time are discrete, and the physical quantities take on a finite set of discrete values. A cellular automaton consists of a lattice (or array), usually infinite, of discrete-valued variables. The state of such automaton is completely specified by the values of the variables at each place in the lattice. Cellular automata evolve in discrete time steps, with the value at each place (cell) being affected by the values of variables at sites in its neighborhood on the previous time step. For each automaton there is a set of rules that define its evolution.
For most cellular automata there are configurations (states) that are unreachable: no state will produce them by the application of the evolution rules. These states are called Gardens of Eden for they can only appear as initial states. As an example consider a trivial set of rules that evolve every cell into 0; for this automaton any state with non-zero cells is a Garden of Eden.

In general, finding the ancestor of a given state (or the non-existence of such ancestor) is a very hard, compute intensive, problem. For the sake of simplicity we will restrict the problem to 1-dimensional binary finite cellular automata. This is, the number of cells is a finite number, the cells are arranged in a linear fashion and their state will be either 0 or 1. To further simplify the problem each cell state will depend only on its previous state and that of its immediate neighbors (the one to the left and the one to the right).

The actual arrangement of the cells will be along a circumference, so that the last cell is next to the first.

Problem definition

Given a circular binary cellular automaton you must find out whether a given state is a Garden of Eden or a reachable state. The cellular automaton will be described in terms of its evolution rules. For example, the table below shows the evolution rules for the automaton: Cell=XOR(Left,Right).

Left	Cell	Right	New
[i-1]	[i]	[i + 1]	State
0	0	0	0	 	0 * 20
 0	0	1	1	 	1 * 21
0	1	0	0	 	0 * 22
0	1	1	1	 	1 * 23
1	0	0	1	 	1 * 24
1	0	1	0	 	0 * 25
1	1	0	1	 	1 * 26
1	1	1	0	 	0 * 27
90	 	=	Automaton Identifier


Notice that, with the restrictions imposed to this problem, there are only 256 different automata. An identifier for each automaton can be generated by taking the New State vector and interpreting it as a binary number (as shown in the table). For instance, the automaton in the table has identifier 90. The Identity automaton (every state evolves to itself) has identifier 204.

Input

The input will consist of several test cases. Each input case will describe, in a single line, a cellular automaton and a state. The first item in the line will be the identifier of the cellular automaton you must work with. The second item in the line will be a positive integer N (  $4 \le N \le 32$) indicating the number of cells for this test case. Finally, the third item in the line will be a state represented by a string of exactly N zeros and ones. Your program must keep reading lines until the end of the input (end of file).
Output

If an input case describes a Garden of Eden you must output the string GARDEN OF EDEN. If the input does not describe a Garden of Eden (it is a reachable state) you must output the string REACHABLE.
The output for each test case must be in a different line.

Sample Input

0 4 1111
204 5 10101
255 6 000000
154 16 1000000000000000
Sample Sample Output

GARDEN OF EDEN
REACHABLE
GARDEN OF EDEN
GARDEN OF EDEN


Miguel Revilla
2000-08-21

*/